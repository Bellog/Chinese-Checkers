package org.example.client;

import org.example.ARuleSet;
import org.example.Pair;
import org.example.connection.Packet;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

public class GamePanel extends JPanel {

    private final List<List<Field>> board = new ArrayList<>();
    private final int playerId;
    private final List<Color> colorScheme;
    //TODO boardBackground should be generated by server based on fieldDim and returned to client
    // this will allow to remove client's dependency on ruleSet completely (move it to server afterwards)
    // it's possible since only creation of boardBackground is dependent on ruleSet
    private final Dimension fieldDim = new Dimension(28, 48);
    private final BufferedImage boardBackground;
    private final ARuleSet ruleSet;
    private final IClient client;

    GamePanel(int playerId, List<Color> colorScheme, ARuleSet ruleSet, IClient client) {
        this.playerId = playerId;
        this.colorScheme = colorScheme;
        this.ruleSet = ruleSet;
        this.client = client;

        for (int y = 0; y < ruleSet.getBoard().size(); y++) {
            board.add(new ArrayList<>());
            for (int x = 0; x < ruleSet.getBoard().get(0).size(); x++) {
                if (ruleSet.getBoard().get(y).get(x) == null) {
                    board.get(y).add(null);
                    continue;
                }
                board.get(y).add(new Field(new Pair(x, y), ruleSet.getBoard()));
            }
        }

        boardBackground = createBoardBackground();

        initMouseListener();
        setVisible(true);
    }

    private void initMouseListener() {
        //TODO block movement if action is incorrect
        //TODO rework code so that id doesn't use ruleSet internally,
        // send requests to server instead (i.e. request possible moves)
        addMouseListener(new MouseAdapter() {
            private Pair first = null;
            private List<Pair> selected = null;

            private Pair getPosition(MouseEvent e) {
                int x = e.getX();
                int y = e.getY();
                int posX = 0;
                int posY = 0;
                while (x > fieldDim.width) {
                    posX++;
                    x -= fieldDim.width;
                }
                while (y > fieldDim.height) {
                    posY++;
                    y -= fieldDim.height;
                }

                // if x or y are outside of a circle (field), then mouseEvent should not do anything
                int diameter = Math.min(fieldDim.height, fieldDim.width);
                if (y < (fieldDim.height - diameter) / 2 ||
                    y > diameter + (fieldDim.height - diameter) / 2 ||
                    x < (fieldDim.width - diameter) / 2 ||
                    x > diameter + (fieldDim.width - diameter) / 2)
                    return null;

                return new Pair(posX, posY);
            }

            @Override
            public void mouseClicked(MouseEvent e) {
                var pos = getPosition(e);
                if (pos == null)
                    return;
                Field f = board.get(pos.second).get(pos.first);
                if (f == null)
                    return;

                if (f.getState() != playerId && f.getState() != -1)
                    return; // field is occupied by another player }

                if (first == null) {
                    firstClick(pos, f);
                } else
                    secondClick(pos, f);

            }

            private void secondClick(Pair pos, Field f) {
                if (pos == first) {
                    f.setSelected(false);
                    first = null;
                    for (Pair field : selected)
                        board.get(field.second).get(field.first).setSelected(false);
                    selected = null;
                } else {
                    for (Pair second : selected) {
                        if (!second.equals(pos))
                            continue;

                        if (f.getState() == -1) {
                            f.setState(playerId);
                            board.get(first.second).get(first.first).setState(-1);
                            client.send(new Packet.PacketBuilder().code(Packet.Codes.PLAYER_MOVE)
                                    .start(first).end(pos).build());
                            for (Pair field : selected)
                                if (field != null)
                                    board.get(field.second).get(field.first).setSelected(false);
                            first = null;
                            selected = null;
                            return; // this should happen only once per
                        }
                    }
                }
            }

            private void firstClick(Pair pos, Field f) {
                if (f.getState() == playerId) {
                    selected = ruleSet.getPossibleMoves(pos);
                    if (selected.size() == 0)
                        return;

                    first = pos;
                    for (Pair field : selected)
                        board.get(field.second).get(field.first).setSelected(true);
                }
            }
        });
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(board.get(0).size() * fieldDim.width, board.size() * fieldDim.height);
    }

    void update(List<List<Pair>> board) {
        for (int y = 0; y < board.size(); y++) {
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null)
                    continue;
                this.board.get(y).get(x).setState(board.get(y).get(x).first);
            }
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        var g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.drawImage(boardBackground, 0, 0, boardBackground.getWidth(), boardBackground.getHeight(), null);
        for (int y = 0; y < board.size(); y++) {
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null)
                    continue;
                int diameter = Math.min(fieldDim.height, fieldDim.width);
                if (board.get(y).get(x).getState() >= 0)
                    g2d.setColor(colorScheme.get(board.get(y).get(x).getState()));
                else
                    g2d.setColor(Color.WHITE);

                g2d.fillOval(x * fieldDim.width, y * fieldDim.height + (fieldDim.height - diameter) / 2, diameter, diameter);

                g2d.setColor(Color.BLACK);
                if (board.get(y).get(x).isSelected())
                    g2d.setStroke(new BasicStroke(4));
                else
                    g2d.setStroke(new BasicStroke(2));
                g2d.drawOval(x * fieldDim.width, y * fieldDim.height + (fieldDim.height - diameter) / 2, diameter, diameter);
            }
        }
    }

    private void drawBackground(Graphics2D g) {
        g.setStroke(new BasicStroke(4));
        g.setColor(Color.BLACK);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        for (int y = 0; y < board.size(); y++) {
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null)
                    continue;
                var neighs = ruleSet.getNeighbors(new Pair(x, y));
                drawBackgroundFieldBase(new Pair(x, y), neighs, g);
            }
        }
        for (int y = 0; y < board.size(); y++) {
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null)
                    continue;
                var neighs = ruleSet.getNeighbors(new Pair(x, y));
                for (Pair p : neighs) {
                    if (p != null)
                        g.drawLine(x * fieldDim.width + fieldDim.width / 2,
                                y * fieldDim.height + fieldDim.height / 2,
                                p.first * fieldDim.width + fieldDim.width / 2,
                                p.second * fieldDim.height + fieldDim.height / 2);
                }
            }
        }
    }

    private BufferedImage createBoardBackground() {
        BufferedImage background = new BufferedImage(fieldDim.width * board.get(0).size(),
                fieldDim.height * board.size(), BufferedImage.TYPE_3BYTE_BGR);
        Graphics2D g = (Graphics2D) background.getGraphics();
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, fieldDim.width * board.get(0).size(), fieldDim.height * board.size());

        drawBackground(g);

        return background;
    }

    private void drawBackgroundFieldBase(Pair pos, List<Pair> neighs, Graphics2D g) {
        if (board.get(pos.second).get(pos.first).getType() >= 0) { // field is a base
            var gg = g.create();

            for (int i = 0; i < neighs.size() - 1; i++) {

                drawBackgroundFieldBaseTile(pos, neighs.get(i), neighs.get(i + 1), gg);
            }
            if (neighs.size() > 2)  // n,0 wont happen in loop above if n > 1
                drawBackgroundFieldBaseTile(pos, neighs.get(neighs.size() - 1), neighs.get(0), gg);
            gg.dispose();
        }
    }

    private void drawBackgroundFieldBaseTile(Pair pos, Pair neigh0, Pair neigh1, Graphics g) {
        if (neigh0 == null || neigh1 == null)
            return;

        int[] xs = {pos.first * fieldDim.width + fieldDim.width / 2,
                neigh0.first * fieldDim.width + fieldDim.width / 2,
                neigh1.first * fieldDim.width + fieldDim.width / 2};
        int[] ys = {pos.second * fieldDim.height + fieldDim.height / 2,
                neigh0.second * fieldDim.height + fieldDim.height / 2,
                neigh1.second * fieldDim.height + fieldDim.height / 2};
        g.setColor(colorScheme.get(board.get(pos.second).get(pos.first).getType()));
        g.fillPolygon(xs, ys, 3);
    }

}
