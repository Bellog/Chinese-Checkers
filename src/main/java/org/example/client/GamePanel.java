package org.example.client;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class GamePanel extends JPanel {

    //TODO boardBackground should be generated by server based on fieldDim and returned to client
    // this will allow to remove client's dependency on ruleSet completely (move it to server afterwards)
    // it's possible since only creation of boardBackground is dependent on ruleSet
    public final static Dimension fieldDim = new Dimension(28, 48);
    private final List<List<Field>> board = new ArrayList<>();
    private final int playerId;
    private final List<Color> colorScheme;
    private final ImageIcon boardBackground;
    private final IClient client;

    GamePanel(int playerId, List<Color> colorScheme, List<List<Integer>> board, IClient client, ImageIcon boardBackground) {
        this.playerId = playerId;
        this.colorScheme = colorScheme;
        this.client = client;
        this.boardBackground = boardBackground;

        for (int y = 0; y < board.size(); y++) {
            this.board.add(new ArrayList<>());
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null) {
                    this.board.get(y).add(null);
                } else
                    this.board.get(y).add(new Field(board.get(y).get(x)));
            }
        }

        initMouseListener();
        setVisible(true);
    }

    private void initMouseListener() {
        //TODO block movement if action is incorrect
        //TODO rework code so that id doesn't use ruleSet internally,
        // send requests to server instead (i.e. request possible moves)
//        addMouseListener(new MouseAdapter() {
//            private Pair first = null;
//            private List<Pair> selected = null;
//
//            private Pair getPosition(MouseEvent e) {
//                int x = e.getX();
//                int y = e.getY();
//                int posX = 0;
//                int posY = 0;
//                while (x > fieldDim.width) {
//                    posX++;
//                    x -= fieldDim.width;
//                }
//                while (y > fieldDim.height) {
//                    posY++;
//                    y -= fieldDim.height;
//                }
//
//                // if x or y are outside of a circle (field), then mouseEvent should not do anything
//                int diameter = Math.min(fieldDim.height, fieldDim.width);
//                if (y < (fieldDim.height - diameter) / 2 ||
//                    y > diameter + (fieldDim.height - diameter) / 2 ||
//                    x < (fieldDim.width - diameter) / 2 ||
//                    x > diameter + (fieldDim.width - diameter) / 2)
//                    return null;
//
//                return new Pair(posX, posY);
//            }
//
//            @Override
//            public void mouseClicked(MouseEvent e) {
//                var pos = getPosition(e);
//                if (pos == null)
//                    return;
//                Field f = board.get(pos.second).get(pos.first);
//                if (f == null)
//                    return;
//
//                if (f.getState() != playerId && f.getState() != -1)
//                    return; // field is occupied by another player }
//
//                if (first == null) {
//                    firstClick(pos, f);
//                } else
//                    secondClick(pos, f);
//
//            }
//
//            private void secondClick(Pair pos, Field f) {
//                if (pos == first) {
//                    f.setSelected(false);
//                    first = null;
//                    for (Pair field : selected)
//                        board.get(field.second).get(field.first).setSelected(false);
//                    selected = null;
//                } else {
//                    for (Pair second : selected) {
//                        if (!second.equals(pos))
//                            continue;
//
//                        if (f.getState() == -1) {
//                            f.setState(playerId);
//                            board.get(first.second).get(first.first).setState(-1);
//                            client.send(new Packet.PacketBuilder().code(Packet.Codes.PLAYER_MOVE)
//                                    .start(first).end(pos).build());
//                            for (Pair field : selected)
//                                if (field != null)
//                                    board.get(field.second).get(field.first).setSelected(false);
//                            first = null;
//                            selected = null;
//                            return; // this should happen only once per
//                        }
//                    }
//                }
//            }
//
//            private void firstClick(Pair pos, Field f) {
//                if (f.getState() == playerId) {
//                    selected = ruleSet.getPossibleMoves(pos);
//                    if (selected.size() == 0)
//                        return;
//
//                    first = pos;
//                    for (Pair field : selected)
//                        board.get(field.second).get(field.first).setSelected(true);
//                }
//            }
//        });
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(board.get(0).size() * fieldDim.width, board.size() * fieldDim.height);
    }

    void update(List<List<Integer>> board) {
        for (int y = 0; y < board.size(); y++) {
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null)
                    continue;
                this.board.get(y).get(x).setState(board.get(y).get(x));
            }
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        var g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.drawImage(boardBackground.getImage(), 0, 0, boardBackground.getIconWidth(), boardBackground.getIconHeight(), null);
        for (int y = 0; y < board.size(); y++) {
            for (int x = 0; x < board.get(0).size(); x++) {
                if (board.get(y).get(x) == null)
                    continue;
                int diameter = Math.min(fieldDim.height, fieldDim.width);
                if (board.get(y).get(x).getState() >= 0)
                    g2d.setColor(colorScheme.get(board.get(y).get(x).getState()));
                else
                    g2d.setColor(Color.WHITE);

                g2d.fillOval(x * fieldDim.width, y * fieldDim.height + (fieldDim.height - diameter) / 2, diameter, diameter);

                g2d.setColor(Color.BLACK);
                if (board.get(y).get(x).isSelected())
                    g2d.setStroke(new BasicStroke(4));
                else
                    g2d.setStroke(new BasicStroke(2));
                g2d.drawOval(x * fieldDim.width, y * fieldDim.height + (fieldDim.height - diameter) / 2, diameter, diameter);
            }
        }
    }

}
